\import Algebra.Group
\import Algebra.Group.GroupCategory
\import Algebra.Group.GroupHom
\import Algebra.Group.Sub
\import Algebra.Meta
\import CommutatorRelations
\import Function.Meta
\import Logic
\import Meta
\import NilpotentGroup
\import Paths.Meta
\import Set
\import grouplib

-- truncation here is entirely unnecessary, but for now it is easier
\func commutators-subset {G : Group} (A B : SubSet G) : SubSet G \cowith
  | contains x => TruncP (\Sigma (a b : G) (A a) (B b) (x = comm a b))


\func comm-invariant {G : Group}
                     (theta : GroupHom G G)
                     (A B : SubSet G)
                     (a-inv : is-transformation-invariant-SubSet A theta)
                     (b-inv : is-transformation-invariant-SubSet B theta)
  : is-transformation-invariant-SubSet (commutators-subset A B) theta =>
  \lam (inP (a,b, in-A, in-B, x=comm)) =>
      inP (theta a, theta b, a-inv in-A, b-inv in-B,
        rewriteEq (x=comm,
                   theta.func-*,
                   theta.func-*,
                   theta.func-*,
                   theta.func-inverse,
                   theta.func-inverse) $ equation.group)

\func commutatorSubgroup {G : Group} (A B : SubSet G) : SubGroup G => subGroupClosure (commutators-subset A B)

\func commutatorInvariant {G : Group}
                          {theta : GroupHom G G}
                          (A B : SubSet G)
                          (A-inv : is-transformation-invariant-SubSet A theta)
                          (B-inv : is-transformation-invariant-SubSet B theta)
  : is-transformation-invariant-SubSet (commutators-subset A B) theta =>
  \lam (inP (a,b, in-A, in-B, x=comm)) =>
      inP (theta a, theta b, A-inv in-A, B-inv in-B,
      rewriteEq x=comm $ rewriteEq (theta.func-*,
                                    theta.func-*,
                                    theta.func-*,
                                    theta.func-inverse,
                                    theta.func-inverse) equation.group)
\where {
  \func commutatorSubgroupInv {G : Group} {theta : GroupHom G G} (A B : SubSet G) (A-inv : is-transformation-invariant-SubSet A theta)
                              (B-inv : is-transformation-invariant-SubSet B theta) : is-transformation-invariant-SubSet (commutatorSubgroup A B) theta
    => InvariantGenerated (commutators-subset A B) (commutatorInvariant A B A-inv B-inv)
}


\func commNormalSubgroup {G : Group} (A B : NormalSubGroup G) : NormalSubGroup {| SubGroup => commutatorSubgroup A B } \cowith
  | isNormal g {h} x =>
    commutatorInvariant.commutatorSubgroupInv A B (normal-is-conj-inv A g) (normal-is-conj-inv B g) {h} x
  \where {
    \func normal-is-conj-inv (A : NormalSubGroup G) (g : G) : is-transformation-invariant-SubSet A (conjugateHom g)
      => \lam in-A => isNormal g in-A
  }

\func lowerCentralSeries_1+ (n : Nat) (G : Group) : NormalSubGroup G \elim n
  | 0 => upSubGroup
  | suc n => commNormalSubgroup (lowerCentralSeries_1+ n G) upSubGroup
