\import Algebra.Group
\import Algebra.Group.GroupCategory
\import Algebra.Group.GroupHom
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid.Sub
\import CommutatorRelations
\import Function.Iterate
\import Function.Meta
\import LowerCentralSeries
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Logic
\import grouplib

\func isNilpotentGroupOfClass (k : Nat) (G : Group) : \Prop
  => isTrivialSubGroup (lowerCentralSeries_1+ k G)

\func nilpotentOfClass0<->trivial (G : Group) : isTrivialGroup G <-> isNilpotentGroupOfClass 0 G =>
  (
    \lam isTriv => \lam a _ => isTriv a,
    \lam isNilp => \lam a => isNilp a ()
  )


\func nilpotentOfClass1<->abelian (G : Group) : isAbelianGroup G <-> isNilpotentGroupOfClass 1 G =>
  (Abelian=>IsNilpotent, IsNilpotent1=>Abelian)
\where \private{
  \func Abelian=>IsNilpotent (ab : isAbelianGroup G) : isNilpotentGroupOfClass 1 G
    => generatedByIde (commutators-subset nonProperSubgroup nonProperSubgroup)
        (\lam (inP (x, y, _, _, a=xy)) => rewriteEq a=xy $ unfold comm $ rewriteEq (ab (inverse y) x, inv Group.*-assoc) $ rewrite (Group.inverse-left, Group.ide-left, Group.inverse-left) idp)
        (SubGroupClosure (commutators-subset nonProperSubgroup nonProperSubgroup))

  \func IsNilpotent1=>Abelian (p : isNilpotentGroupOfClass 1 G) : isAbelianGroup G
    => \lam a b =>
        \let s : comm a b = G.ide => p (comm a b) (inP (0, byRight $ byLeft $ inP (a, b, (), (), idp))) \in
        rewriteI {4} Group.ide-right $ rewriteI s $ equation.group
}