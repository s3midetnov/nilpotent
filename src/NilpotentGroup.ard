\import Algebra.Group
\import Algebra.Group.GroupCategory
\import Algebra.Group.GroupHom
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid.Sub
\import CommutatorRelations
\import Function.Iterate
\import Function.Meta
\import Meta
\import Paths
\import Set
\import Logic

-- 1. First, we define some standard subgroups.

\data True : \Prop
  | true

\instance fullSubgroup {G : Group} : NormalSubGroup G
  | contains => \lam _ => True
  | contains_ide => true
  | contains_* => \lam _ _ => true
  | contains_inverse => \lam _ => true
  | isNormal _ _ => true
--   | isDec => \lam _ => yes true

\instance trivialSubgroup {G : Group} : SubGroup G
  | contains x => x = G.ide
  | contains_ide => idp
  | contains_* x=e y=e => rewriteEq (x=e, y=e) $ idp
  | contains_inverse x=e => rewriteEq x=e $ equation.group

\func isTrivial {G : Group} (A : SubGroup G) : \Prop
  => \Pi (a : G) (A a) -> a = G.ide

-- 2. Definition of the subgroup generated by a subset. I think this should be part of arend-lib
\func contains-inverses {G : Group} (S : SubSet G) : \Prop => \Pi {x : G} (S.contains x) -> S.contains (inverse x)

\record IsClosed {G : Group} (S : SubSet G)
  | contains-inverse {x : G} : S.contains x -> S.contains (inverse x)
  | contains-ide : S.contains G.ide

\func apl-closed {G : Group} {S : SubSet G} (S-closed : IsClosed S)
  : IsClosed (SubMonoid.closure.apl S)
  \cowith
    | contains-ide => byRight $ byLeft $ idp
    | contains-inverse c =>
      \case\elim c \with {
      | byLeft a => byLeft $ S-closed.contains-inverse a
      | byRight b => \case\elim b \with {
        | byLeft x=ide => byRight $ byLeft $ rewriteEq x=ide equation.group
        | byRight (a, b, s-a, s-b, eq) => byRight $ byRight $ (inverse b, inverse a, S-closed.contains-inverse s-b, S-closed.contains-inverse s-a, rewriteEq eq $ equation.group)
    }
  }

\func iterr-apl-closed {G : Group} {S : SubSet G} (n : Nat) (S-closed : IsClosed S)
  : IsClosed (iterr SubMonoid.closure.apl n S)
  \elim n
    | 0 => S-closed
    | suc n => apl-closed (iterr-apl-closed n S-closed)

\instance product-closure {G : Group} (S : SubSet G) (S-closed : IsClosed S)
: SubGroup G
  | SubMonoid => SubMonoid.closure S
  | contains_inverse {x} (inP (n, s)) =>
    inP (n, (iterr-apl-closed n S-closed).contains-inverse {x} s)

\instance inverse-closure {G : Group} (S : SubSet G) : SubSet G
  | contains x => (x = G.ide) || S x || S (inverse x)
\func inverse-closure-is-closed {G : Group} (S : SubSet G) : IsClosed (inverse-closure S)
  \cowith
    | contains-inverse (x-in) => \case\elim x-in \with {
      | byLeft a => byLeft $ rewriteEq a $ equation.group
      | byRight b => \case\elim b \with {
        | byLeft a => byRight $ byRight $ rewriteEq Group.inverse-isInv a
        | byRight b => byRight $ byLeft $ b
      }
    }
    | contains-ide => byLeft idp

\instance closure {G : Group} (S : SubSet G) : SubGroup G
  => product-closure (inverse-closure S) (inverse-closure-is-closed S)

\func IsInvariantSubSet {E : BaseSet} (A : SubSet E) (theta : E -> E) : \Prop
  => \Pi {x : E} (A x) -> A (theta x)

\func comm-invariant {G : Group} (theta : GroupHom G G) (A B : SubSet G)
  (a-inv : IsInvariantSubSet A theta) (b-inv : IsInvariantSubSet B theta)
  : IsInvariantSubSet (commutators-subset A B) theta
=> \lam (inP (a,b, in-A, in-B, x=comm)) =>
    inP (theta a, theta b, a-inv in-A, b-inv in-B, rewriteEq (x=comm, theta.func-*, theta.func-*, theta.func-*, theta.func-inverse, theta.func-inverse) $ equation.group)

-- 3. Proof that invariance under homomorphism continues from the generating set onto the whole subgroup
\func InvariantGenerated {G : Group} {theta : GroupHom G G} (A : SubSet G)
                         (A-inv : IsInvariantSubSet A theta)
                         : IsInvariantSubSet (closure A) theta
  => \lam (in-cl) => \case\elim in-cl \with {
    | inP (n, p) => inP
        (n, iterr-apl-invariant (inverse-closure A) (closure-inv A A-inv) n p)
  }
  \where {
    \func closure-inv (A : SubSet G) (A-inv : IsInvariantSubSet A theta)
      : IsInvariantSubSet (inverse-closure A) theta
      => \lam in-cl => \case\elim in-cl \with {
        | byLeft x=ide => rewriteEq x=ide $ byLeft $ rewriteEq theta.func-ide idp
        | byRight b => \case\elim b \with {
          | byLeft a => byRight $ byLeft $ A-inv a
          | byRight b => byRight $ byRight $ rewriteEq (inv $ theta.func-inverse) $ A-inv b
        }
      }

    \func apl-invariant (A : SubSet G) (A-inv : IsInvariantSubSet A theta)
      : IsInvariantSubSet (SubMonoid.closure.apl A) theta
      => \lam (in-apl) => \case\elim in-apl \with {
        | byLeft in-A => byLeft (A-inv in-A)
        | byRight b => \case\elim b \with {
          | byLeft x=ide => rewriteEq (x=ide, theta.func-ide) (byRight $ byLeft idp)
          | byRight (y,z, y-A, z-A, x=yz) => rewriteEq (x=yz, theta.func-*) $ byRight $ byRight (theta y, theta z, A-inv y-A, A-inv z-A, idp)
        }
      }

    \func iterr-apl-invariant (A : SubSet G) (A-inv : IsInvariantSubSet A theta) (n : Nat)
      : IsInvariantSubSet (iterr SubMonoid.closure.apl n A) theta
      \elim n
        | 0 => A-inv
        | suc n => apl-invariant (iterr SubMonoid.closure.apl n A) (iterr-apl-invariant A A-inv n)
  }

-- 4. The commutator subgroup
\func commutators-subset {G : Group} (A B : SubSet G) : SubSet G \cowith
  | contains x => TruncP (\Sigma (a b : G) (A a) (B b) (x = comm a b))
--           -- truncation here is entirely unnecessary, but for now it is easier

\func CommutatorSubgroup {G : Group} (A B : SubSet G) : SubGroup G
  => closure (commutators-subset A B)

-- 5. Apply step 3 to the commutator subgroups. This will be needed to prove that the lower central series is normal
\func commutatorInvariant {G : Group} {theta : GroupHom G G} (A B : SubSet G) (A-inv : IsInvariantSubSet A theta)
                          (B-inv : IsInvariantSubSet B theta)
  : IsInvariantSubSet (commutators-subset A B) theta
  => \lam (inP (a,b, in-A, in-B, x=comm)) => inP $ (theta a, theta b, A-inv in-A, B-inv in-B,
  rewriteEq x=comm $ rewriteEq (theta.func-*, theta.func-*, theta.func-*, theta.func-inverse, theta.func-inverse) equation.group)

\func commutatorSubgroupInv {G : Group} {theta : GroupHom G G} (A B : SubSet G) (A-inv : IsInvariantSubSet A theta)
                            (B-inv : IsInvariantSubSet B theta) : IsInvariantSubSet (CommutatorSubgroup A B) theta
=> InvariantGenerated (commutators-subset A B) (commutatorInvariant A B A-inv B-inv)

\func CommNormalSubgroup {G : Group} (A B : NormalSubGroup G) : NormalSubGroup {| SubGroup => CommutatorSubgroup A B } \cowith
  | isNormal g {h} x =>
    commutatorSubgroupInv A B (normal-is-conj-inv A g) (normal-is-conj-inv B g) {h} x
\where {
  \func normal-is-conj-inv (A : NormalSubGroup G) (g : G) : IsInvariantSubSet A (conjugateHom g)
    => \lam in-A => isNormal g in-A

}
-- | The n-th term of the lower central series.
\func lowerCentralSeries (G : Group) (n : Nat) : NormalSubGroup G\elim n
  | 0 => fullSubgroup   -- Usually indexed starting at 1, but 0 is convenient for recursion
  | suc n => CommNormalSubgroup (lowerCentralSeries G n) fullSubgroup

-- | A group is nilpotent of class <= c if the c-th term of the series is the trivial subgroup.
\func IsNilpotentGroupOfClass (G : Group) (c : Nat) : \Prop
  => isTrivial (lowerCentralSeries G c)
-- Thus, a group of class <= 0 is the trivial group, any abelian group is of class <= 1
