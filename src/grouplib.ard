\import Algebra.Group
\import Algebra.Group.Free
\import Algebra.Group.GroupCategory
\import Algebra.Group.GroupHom
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.FreeMonoid
\import Algebra.Monoid.MonoidHom
\import Algebra.Monoid.Sub
\import Data.List
\import Function.Iterate
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set

{- | This is a file that contains definitions that should definitely be in arend-lib -}


{- | 1. Monoid definitions. Goes to Algebra/Monoid/Category and .../Sub.
 - Submonoid generated by subset is already present as Monoid/Sub#closure, however
 - TODO: prove that Monoid/Sub#closure gives the same submonoid as the GeneratedSubMonoid below
 -  -}

-- | is it possible to rewrite this using ImageMonoid and epi-mono?
\func imageSubMonoid{N M : Monoid} (f : MonoidHom N M) : SubMonoid M \cowith
  | contains m => âˆƒ (n : N) (f n = m)
  | contains_ide => inP (N.ide, f.func-ide)
  | contains_* c_p c_n => \case c_p, c_n \with {
    | inP t, inP s => inP (t.1 * s.1, func-* *> pmap2 (*) t.2 s.2)
  }

\func generatedSubMonoid{M : Monoid} (S : SubSet M) : SubMonoid M
  => imageSubMonoid {ListMonoid {S.ISet}} {M} (universalFreeMonoidMap (\lam x => x.1))


{- | 2. Subgroups. Goes to Algebra/Group/Sub -}

\func nonProperSubgroup {G : Group} : NormalSubGroup G \cowith
  | contains => \lam _ => \Sigma
  | contains_ide => ()
  | contains_* => \lam _ _ => ()
  | contains_inverse => \lam _ => ()
  | isNormal _ _ => ()

\instance trivialSubgroup {G : Group} : NormalSubGroup G
  | contains x => x = G.ide
  | contains_ide => idp
  | contains_* x=e y=e => rewriteEq (x=e, y=e) $ idp
  | contains_inverse x=e => rewriteEq x=e $ equation.group
  | isNormal _ h=1 => rewrite h=1 equation.group

\func isTrivialSubGroup {G : Group} (A : SubGroup G) : \Prop
  => \Pi (a : G) (A a) -> a = G.ide


{- | 3. Subgroups generated by subsets. Goes to either Algebra/Group/Sub or in another file.
 - There are several possible definitions, two of them are presented here.
 - Option 1. Define it as a image subgroup of the universally defined homomorphism from a free group
 - Option 2. Take elements, consider their products
 - Option 3 (not presented here, but probably the best one). Define subgroup generated by S as
 - the submonoid generated by $S \cup S^{ -1}$. This way, it is conceptual since it uses universal properties,
 - but computationally simpler than Option 1. since it doesn't involve working with the free group.
 -  -}

-- Option 1
\func GeneratedSubGroup{G : Group}(S : SubSet G)
  => ImageSubGroup (FreeGroupUniversalProperty S.ISet G (\lam x => x.1)).1


-- Option 2
\func contains-inverses {G : Group} (S : SubSet G) : \Prop => \Pi {x : G} (S.contains x) -> S.contains (inverse x)

\open SubMonoid.closure \hiding (ext)

\instance subGroupClosure {G : Group} (S : SubSet G) : SubGroup G
=> product-closure (inverse-closure S) (inverse-closure-is-closed S)
    \where \protected{

      \record IsInvClosed {G : Group} (S : SubSet G)
        | contains-inverse {x : G} : S.contains x -> S.contains (inverse x)
        | contains-ide : S.contains G.ide

      \func apl-closed {G : Group}{S : SubSet G} (S-closed : IsInvClosed S) : IsInvClosed (apl S) \cowith
        | contains-ide => byRight $ byLeft $ idp
        | contains-inverse c =>
          \case\elim c \with {
            | byLeft a => byLeft $ S-closed.contains-inverse a
            | byRight b => \case\elim b \with {
              | byLeft x=ide => byRight $ byLeft $ rewriteEq x=ide equation.group
              | byRight (a, b, s-a, s-b, eq) => byRight $ byRight $ (inverse b, inverse a, S-closed.contains-inverse s-b, S-closed.contains-inverse s-a, rewriteEq eq $ equation.group)
            }
          }

      \func iterr-apl-closed {G : Group} {S : SubSet G} (n : Nat) (S-closed : IsInvClosed S)
        : IsInvClosed (iterr apl n S)
      \elim n
        | 0 => S-closed
        | suc n => apl-closed (iterr-apl-closed n S-closed)

      \func product-closure {G : Group} (S : SubSet G) (S-closed : IsInvClosed S)
      : SubGroup G\cowith
        | SubMonoid => SubMonoid.closure S
        | contains_inverse {x} (inP (n, s)) =>
          inP (n, (iterr-apl-closed n S-closed).contains-inverse {x} s)

      \func inverse-closure {G : Group} (S : SubSet G) : SubSet G\cowith
        | contains x => (x = G.ide) || S x || S (inverse x)
      \func inverse-closure-is-closed {G : Group} (S : SubSet G) : IsInvClosed (inverse-closure S)
      \cowith
        | contains-inverse (x-in) => \case\elim x-in \with {
          | byLeft a => byLeft $ rewriteEq a $ equation.group
          | byRight b => \case\elim b \with {
            | byLeft a => byRight $ byRight $ rewriteEq Group.inverse-isInv a
            | byRight b => byRight $ byLeft $ b
          }
        }
        | contains-ide => byLeft idp
    }

{- | 3.5 Interface for generated subgroups -}
\func contains-subset {G : Group} (S : SubSet G) (H : SubGroup G) => \Pi {s : G} (in-S : S s) -> H s

\class GeneratedSubgroup-General {G : Group} (S : SubSet G)
  | \classifying sub : SubGroup G
  | contains : contains-subset S sub
  | minimal : \Pi (H : SubGroup G) (contains-subset S H) -> sub SubGroupPreorder.<= H
\where {
  -- | If it exists, the generated subgroup is unique
  \use\level isProp {G : Group} (S : SubSet G) (x : GeneratedSubgroup-General S) (y : GeneratedSubgroup-General S) : x = y
    =>
      \let x<=y => x.minimal y.sub y.contains
      | y<=x => y.minimal x.sub x.contains
      \in
      ext $ exts $ \lam g => propExt (x<=y g) (y<=x g)
    -- | This should definitely be refactored,
    -- | SubgroupPreorder should be just SubGroupOrder in the standard library
}

\func SubGroupClosure {G : Group} (S : SubSet G) : GeneratedSubgroup-General S\cowith
    | sub => subGroupClosure {G} S
    | contains s-in => inP (0, byRight $ byLeft s-in)
    | minimal => sub-contained
    \where \protected{
    \func inv-contained (H : SubGroup G) (S<=H : contains-subset S H)
      : contains-subset (subGroupClosure.inverse-closure S) H
      => \lam in-inv-cl => \case\elim in-inv-cl \with {
        | byLeft a => rewriteEq a $ H.contains_ide
        | byRight b => \case\elim b \with {
          | byLeft a => S<=H a
          | byRight b => rewriteI Group.inverse-isInv $ H.contains_inverse (S<=H b)
        }
      }

    \func sub-contained (H : SubGroup G) (S<=H : contains-subset S H) : (subGroupClosure S) SubGroupPreorder.<= H
      => SubMonoid.closure.univ H (unfold $ \lam x => inv-contained H S<=H {x})
    }

 {- | 3.75 Trivial subgroup is generated by ide -}

\func subset-is-ide {G : Group} (A : SubSet G) => \Pi {a : G} (in-A : A a) -> a = G.ide

\func generatedByIde {G : Group} (S : SubSet G) (S-is-ide : subset-is-ide S)
                      (H : GeneratedSubgroup-General S) : isTrivialSubGroup H.sub
  => \lam _ => rewrite (GeneratedSubgroup-General.isProp S H generated-is-trivial) $ \lam x=ide => x=ide
  \where \private{
    \func generated-is-trivial : GeneratedSubgroup-General S trivialSubgroup \cowith
      | contains => S-is-ide
      | minimal H _ => \lam _ x=ide => rewriteEq x=ide $ H.contains_ide
  }

{- | 4. Invariant subsets -}
\func IsInvariantSubSet {E : BaseSet} (A : SubSet E) (theta : E -> E) : \Prop
  => \Pi {x : E} (A x) -> A (theta x)

\func InvariantGenerated {G : Group} {theta : GroupHom G G} (A : SubSet G)
                         (A-inv : IsInvariantSubSet A theta)
  : IsInvariantSubSet (subGroupClosure A) theta
  => \lam (in-cl) => \case\elim in-cl \with {
    | inP (n, p) => inP
        (n, iterr-apl-invariant (subGroupClosure.inverse-closure A) (closure-inv A A-inv) n p)
  }
  \where {
    \func closure-inv (A : SubSet G) (A-inv : IsInvariantSubSet A theta)
      : IsInvariantSubSet (subGroupClosure.inverse-closure A) theta
      => \lam in-cl => \case\elim in-cl \with {
        | byLeft x=ide => rewriteEq x=ide $ byLeft $ rewriteEq theta.func-ide idp
        | byRight b => \case\elim b \with {
          | byLeft a => byRight $ byLeft $ A-inv a
          | byRight b => byRight $ byRight $ rewriteEq (inv $ theta.func-inverse) $ A-inv b
        }
      }

    \func apl-invariant (A : SubSet G) (A-inv : IsInvariantSubSet A theta)
      : IsInvariantSubSet (SubMonoid.closure.apl A) theta
      => \lam (in-apl) => \case\elim in-apl \with {
        | byLeft in-A => byLeft (A-inv in-A)
        | byRight b => \case\elim b \with {
          | byLeft x=ide => rewriteEq (x=ide, theta.func-ide) (byRight $ byLeft idp)
          | byRight (y,z, y-A, z-A, x=yz) => rewriteEq (x=yz, theta.func-*) $ byRight $ byRight (theta y, theta z, A-inv y-A, A-inv z-A, idp)
        }
      }

    \func iterr-apl-invariant (A : SubSet G) (A-inv : IsInvariantSubSet A theta) (n : Nat)
      : IsInvariantSubSet (iterr SubMonoid.closure.apl n A) theta
    \elim n
      | 0 => A-inv
      | suc n => apl-invariant (iterr SubMonoid.closure.apl n A) (iterr-apl-invariant A A-inv n)
  }


{- | 5. Misc -}

\func isTrivialGroup (G : Group) => \Pi (a : G) -> a = G.ide

\func isAbelianGroup (G : Group) => \Pi (a b : G) -> a * b = b * a
